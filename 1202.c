- 배열이름은 시작 주소이다. 
  - 배열 이름은 할당된 메모리 공간의 시작주소

int x[] = {1,2,3,4,5};
  - 이때 x[0],x[1],x[2],x[3],x[4]는 각각 변수지만, 
  - x자체는 시작주소를 나타내는 상수다. 
  - 배열의 이름이 x다 : 그 배열의 시작주소가 x이다. 

- 배열을 인수로 전달할 때에는 배열 이름만 전달함
- 매개변수는 일반배열처럼 선언하지만, 이때 크기는 무시됨
무슨 말이야
int sum(int a[10]) //배열을 인수로 전달 중
int sum(int a[]) // 위랑 동일!

그런데 이때 a라는 배열을 선언한 건 아님
함수에서 사용될 인수가 배열인데 이때 전달할 것은 배열 이름만 전달하면 된다는 것!
이때 크기는 무시해도 된다. 

sum이라는 함수를 불러와서 인수 전달해줄 땐?
int main(){
  int x[10]={1,2,3,4,5,6,7,8,9,10};

  printf("1+2+3+4+5+...+10 = %d\n",sum(x));
  return 0 
}
- 이렇게 printf에서 사용된 상황을 보면 함수 sum에 인수로 배열을 전달해주었는데 배열의 이름만 전달해줬음

그런데 배열 길이를 전달해주어야 할 때가 있음
- 배열 매개변수 선언 시 크기는 무시되므로, 필요하면 배열 길이는 별도의 인수로 전달해야 함. 
- 즉, 사용하고 싶으면 별도로 배열의 길이를 선언하여 전달해야 함

배열 인수?
- 배열을 인수로 전달받은 함수에서 배열 원소의 값을 변경하면 원본 배열의 원소 값이 바뀐다. 
- 배열 인수로 배열 이름을 전달한 상황
  - 함수 f에서 함수 g를 호출할 때, 배열 x를 매개변수 a[]에 전달했다면 a는 x의 시작주소이므로
  - 피호출자 g에서 a[1]의 값을 변경하면 x[1]의 값이 변경된다. 


배열하는 방법?
int y[2][3] = {{1,2,3},{4,5,6}}
int y[2][3] = {1,2,3,4,5,6}

주의!!
int y[2][3]={{1,3},{2,3,4}};
int y[2][3]={2,3,4,5,7}

이때 첫 번째 줄은 
1  3  0
2  3  4

그리고 두 번째 줄은
2  3  4
5  7  0

이렇게 된다. 


- 포인터란?
  - 데이터를 저장하기 위해 할당된 메모리 공간의 주소
  - 포인터 상수 : 메모리 주소 값
  - 포인터 변수 : 주소 값을 저장할 수 있는 변수
  - 데이터에는 자료형이 연관되어 있으므로 포인터에도 자료형이 연관됨

- 간접참조(indirection, dereferencing)
  - 포인터가 가리키는 곳을 따라가 연관된 데이터 혹은 그 데이터가 저장된 공간을 참조하는 것
  - 간접참조한 데이터의 자료형은 포인터 자료형을 이용하여 판단함

- 포인터와 일반 변수를 함께 선언
int one, *to_one = &one; // 선언과 함께 초기화



------------------------------------------------
포인터 제 1법칙
- 주소연산을 취한 결과에 간접참조연산을 취하면 원래 변수와 같다. 

포인터를 인수로 전달하면?
- 포인터를 간접참조함으로써 해당 포인터가 가리키는 데이터 값을 변경할 수 있다. 
- 호출된 함수에서 호출한 함수의 변수 값을 변경할 수 있다. 

포인터 인수 전달을 사용하는 이유?
- 호출된 함수의 부수효과로서 호출한 함수의 변수 값을 변경하기 위해
- 인수로 전달할 데이터의 크기가 매우 큰 경우에 인수전달을 효율적으로 하기 위해
- 사실 c에서 배열은 항상 포인터를 통해 전달된다. 

포인터에 가감연산을 취하면 포인터가 가리키는 자료의 크기 단위로 포인터 값이 증감함

#include <stdio.h>

int main(){
  char msg[]= "sdfasdfasdf";
  char *p = msg;

  printf("\n%s\n",msg);
}

- 이때...printf("%s",msg);
- msg대신 p 가능
- *p는 불가능...
  - *p 사용하려면 for문으로?,,,


#include <stdio.h>
#include <string.h>

int main(){

  int i;
  char msg[]= "sdfasdfasdf";
  char *p = msg;

  for(i;i<strlen(p);++i){
    putchar(*(p+i));
}}

포인터 제 2법칙?
- p[n] = *(p+n)
- 배열 이름은 포인터 상수이다. 


배열 포인터? vs 포인터 배열?

- 포인터 배열

#include<stdio.h>
int main(void) {
    const char* arr[3];    //포인터 배열 선언.
    int i;
 
    arr[0] = "BlockDMask";        //arr[0]은 -> 문자열 주소를 가리킵니다.
    arr[1] = "C Programming";    //arr[1]은 -> 문자열 주소를 가리킵니다.
    arr[2] = "point_arr";        //arr[2]은 -> 문자열 주소를 가리킵니다.
 
    for (i = 0; i < 3; i++) 
    {
        printf("arr[%d] -> %s\n", i, arr[i]);
    }
 
    return 0;
}

즉...
int *a[3];
이건 포인터들의 배열임
포인터가 3개 있음
int (*a)[3];
이건 포인터 하나인데
길이가 3인 배열의 포인터가 하나 있는 것!

typedef??

int (*q1)[20];
와
typedef int A[20];
A *q2;

이때 q1과 q2 모두 크기 20인 int 배열에 대한 포인터임

void 포인터는 범용 포인터
- 아무것이나 가리키는 포인터

void 포인터는 간접참조 불가
  - void 포인터는 가리키는 곳의 정보가 없기 때문에 간접 참조가 불가능함
  - void 포인터를 간접참조하려면 먼저 다른 자료형의 포인터로 캐스팅해야 함

void 포인터 p를 캐스팅한 후 간접참조하는 방법
*(int *)p : void 포인터 p를 int형의 포인터로 캐스팅한 후 간접 참조하기
*(float *)p : void 포인터 p를 float형의 포인터로 캐스팅한 후 간접 참조하기

